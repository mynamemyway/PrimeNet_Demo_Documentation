# План разработки базы данных

## Авторизация

1.  По API получаем `initData` с данными.
2.  Проверяем наличие `Telegram_account` в БД по `telegram_id`.
    -   Если нет - создаём сущности `Telegram_account` и `Person` c нашими ID.
    -   Если есть - используем имеющийся `Telegram_account`.
3.  Прикрепляем к `Person` ссылкой `Telegram_account`.
4.  Автоматически наполняем наш `Telegram_account` данными из `initData` (user):
    -   `"id"`: 123456789
    -   `"is_bot"`: false,
    -   `"first_name"`: "John",
    -   `"last_name"`: "Doe",
    -   `"username"`: "johndoe",
    -   `"language_code"`: "en",
    -   `"is_premium"`: true,
    -   `"added_to_attachment_menu"`: false,
    -   `"allows_write_to_pm"`: true,
    -   `"photo_url"`: "https://t.me/i/userpic/320/johndoe.jpg"
5.  Автоматически заполняются поля для `Telegram_account` и для `Person`:
    -   `created_at` - дата добавления сущности (TIMESTAMP).
    -   `updated_at` - дата последнего обновления сущности (TIMESTAMP).
6.  Ставим флаг `is_verified=True`, который указывает, что `Telegram_account` заполнен и был авторизован в системе (живой аккаунт).
7.  Дополнительные поля для ручного ввода для нашего `Telegram_account`:
    -   `phone_number`
8.  Создаём собственную карточку `Contact` для `Person` с флагом `is_self=True`.
9.  Заполняем:
    -   `your_link` - ссылка на любой ресурс для парсинга.
    -   Предлагается кнопка "+", чтобы добавить ссылки на социальные сети из нашего списка соц. сетей.
    -   Далее по списку поля для `Contact` заполняются автоматически после парсинга или вручную при необходимости.

---

## Добавление Контакта по `telegram_id` или `username` (верифицированного аккаунта)

1.  `Person` создаёт `Contact` и вводит `telegram_id` или `username`.
2.  Проверяем в БД наличие `Telegram_account` с этими данными (приоритет - `telegram_id`).
    -   Если есть - прикрепляем ссылку на имеющийся `Telegram_account`.
    -   Если нет - создаём новый `Telegram_account`.
3.  Заполняем `Contact`:
    -   `your_link` - ссылка на любой ресурс для парсинга.
    -   Предлагается кнопка "+", чтобы добавить ссылки на социальные сети из нашего списка соц. сетей.
    -   Далее по списку поля для `Contact` заполняются автоматически после парсинга или вручную при необходимости.

---

## Добавление Контакта по `phone_number`

1.  `Person` создаёт `Contact` и вводит только `phone_number`.
2.  Проверяем в БД наличие `Telegram_account` с этим `phone_number`.
    -   Если находим, прикрепляем `Contact` ссылкой к имеющемуся `Telegram_account`.
    -   Если нет, создаём `Telegram_account` с `is_verified=False` и прикрепляем к нему `Contact`.

> Если позже этот `Telegram_account` получает `id telegram` или `username`, проверяем в БД наличие такого `Telegram_account`. Если есть - привязываем `Contact` к нему, но сохраняем телефон, если он не указан в верифицированном `Telegram_account`. Текущий дубль отправляем в архив - ставим флаг `is_active=False`.
> Если нет, заполняем текущий `Telegram_account` и ставим `is_verified=True`.

3.  Заполняем `Contact`:
    -   `your_link` - ссылка на любой ресурс для парсинга.
    -   Предлагается кнопка "+", чтобы добавить ссылки на социальные сети из нашего списка соц. сетей.
    -   Далее по списку поля для `Contact` заполняются автоматически после парсинга или вручную при необходимости.

---

## Остальные Поля для сущности `Contact`

Категории полей в отдельной таблице:

-   Ссылки на социальные сети (main link for parser)
-   Дополнительные личные данные
-   Предпочтения и взгляды
-   Профессиональные и финансовые данные
-   Дополнительная информация (для контекста и ИИ)

---

## Парсинг

1.  Пользователь видит поле для соц. сетей `your_link`.
2.  После ввода ссылки в `your_link` запускаются `t-a` (text) и `i-a` (image) парсеры в фоновом режиме. User получает уведомление о начале сбора данных.
3.  Сбор данных сохраняется в `parsed_data`, User видит заполненные поля для сохранения.

> *Поле* `shared_contacts` отображает все `Contact` данного `Contact`, если он является `Person`, то есть использует сервис сам.

> *Далее сделаем апгрейд:* каждая социальная сеть - это объект. Пользователь может заполнить любое поле соц. сети ссылкой, получить данные парсингом и эти данные заполняют объект конкретной соц сети и сохраняются в `Contact` этого `Person`. Пользователь может кнопкой "+" добавить данные из любого поля любой соц. сети в основное поле своего `Contact` соответственно.

**Поля:**
- `your_link` # ссылка для парсинга (временно так)
- `vk_link` # ссылка на VK
- `facebook_link` # ссылка на Facebook (Meta)
- `instagram_link` # ссылка на Instagram (Meta)
- `tiktok_link` # ссылка на TikTok
- `x_link` # ссылка Twitter
- `youtube_link` # ссылка на YouTube
- `discord_link` # ссылка на Discord
- `linkedin_link` # ссылка на LinkedIn
- `pinterest_link` # ссылка Pinterest
- `wechat_link` # ссылка на WeChat (asia)
- `line_link` # ссылка на line (asia)

---

## Подробнее о сущностях БД

-   **`Person`** - имеет уникальный внутренний ID, самый глобальный и абстрактный объект. В перспективе может хранить несколько разных аккаунтов для одного реального человека, например при реализации фичи `KYC`. У одного человека может быть несколько `Person`, количество зависит от количества используемых им `Telegram_account` == `phone_number`.
-   **`Telegram_account`** - хранит базовые данные о `Person`, является зеркалом аккаунта в телеграм. Один `Telegram_account` ссылается на одну `Person`.
-   **`Contact`** - это персонализированная страница личного контакта из телефонной книги для конкретного `Person`. `Contact` может иметь множество уникальных персонализированных вариаций одного `Telegram_account`, т.к. создаётся разными пользователями.

Каждая сущность имеет автоматические поля:
-   `created_at` - дата добавления Contact (TIMESTAMP)
-   `updated_at` - дата последнего обновления Contact (TIMESTAMP)

---

## Основные поля для ввода и парсинга в сущность `Contact`

### Ссылки на социальные сети
-   `your_link` # ссылка для парсинга - сейчас для парсинга только это поле
-   `vk_link` # ссылка на VK - 1
-   `facebook_link` # ссылка на Facebook (Meta) - 1
-   `instagram_link` # ссылка на Instagram (Meta) - 1
-   `tiktok_link` # ссылка на TikTok - 1
-   `x_link` # ссылка Twitter - 1
-   `youtube_link` # ссылка на YouTube - 1
-   `discord_link` # ссылка на Discord - 1
-   `linkedin_link` # ссылка на LinkedIn - 1
-   `pinterest_link` # ссылка Pinterest - 1
-   `wechat_link` # ссылка на WeChat (asia) - 1
-   `line_link` # ссылка на line (asia) - 1
-   `your_link` # ссылка на любой ресурс по выбору пользователя (Вручную) - 1

### Дополнительные личные данные
-   `first_name` # Имя. (Вручную, обязательное поле) - 1
-   `last_name` # Фамилия. (Вручную) - 1
-   `middle_name` # Отч. (Вручную) - 1
-   `extra_phone_number` # Телефон, кот. знает Person (Вручную) - 1
-   `email` # Почта (Вручную) - 1
-   `country` # Страна - 1
-   `city` # Город - 1
-   `address` # Адрес по которому проживает - 1
-   `date_of_birth` # Дата рождения - 1
-   `height` # Рост (например, 1.75м) - 1
-   `weight` # Вес (например, 70.5 кг) - 1

### Предпочтения и взгляды
-   `religious_views` # Религиозные взгляды - 2
-   `political_views` # Политические взгляды - 2
-   `personal_qualities` # Личные качества - 2
-   `personal_values` # Личные ценности - 2
-   `content_preferences` # Предпочтения в контенте - 2
-   `music_preferences` # Предпочтения в музыке - 2
-   `drink_preferences` # Предпочтения в напитках - 2
-   `food_preferences` # Предпочтения в еде - 2
-   `harmful_habits` # Вредные привычки - 2
-   `health` # Здоровье - 2
-   `clothing_style` # Стиль одежды - 2
-   `lifestyle` # Стиль жизни - 2
-   `hobbies` # Хобби - 2

### Профессиональные и финансовые данные
-   `development_sphere` # Сфера развития - 1
-   `skills` # Навыки - 1
-   `capital` # Капитал (например 1000000.00) - 1
-   `capital_currency` # Валюта капитала - 1
-   `assets` # Активы (например бизнес) - 1
-   `income_sources` # Источники дохода - 1
-   `investment` # Инвестиции - 1

### Дополнительная информация (для контекста и ИИ)
-   `secrets` # Секреты - 2
-   `problems` # Проблемы - 2
-   `photos_url` # ссылки на изображения, которые были обработаны i-анализом - 2

### Автоматические поля (авторасчёт)
-   `shared_contacts` # getSharedContacts() - автоподбор списка общих контактов
-   `age` # - возраст Contact
-   `created_at` # - дата добавления Contact (TIMESTAMP)
-   `updated_at` # - дата последнего обновления Contact (TIMESTAMP)

> **Легенда приоритетов парсинга:**
> -   **0** - Поля, которые заполняются только пользователем или автоматически / при t-анализе.
> -   **1** - Поля с приоритетом t-анализа (заполняются при i-анализе только если не заполнены после t-анализа).
> -   **2** - Поля для конкатенации (всегда дополняются найденными после i-анализа данными).

---

## Примечания

> -   `Telegram_account`, созданный при добавлении чужого контакта, существует как "контейнер данных" и не обязательно связан с каким-либо `Person` на момент создания. Связь с `Person` произойдет, если этот человек сам авторизуется в системе.
> -   При обновлении `Telegram_account` по `phone_number` добавить проверку на существование `Telegram_account` с таким же `id` или `username`. Если он существует, объединить данные (аналогично логике при добавлении контакта) — перенести связанные `Contact` со "старого" (по номеру) на "новый" (по `id`/`username`), а "старый" пометьте как архивный или удалите.
> -   Флаг `is_verified=False` - это маркер неполных данных.
> -   Уточнение семантики флага `is_verified=True` - "аккаунт подтвержден через Telegram API".
> -   `getSharedContacts()` - автоподбор списка общих контактов. Проверяем, есть ли у контакта прикреплённый `Person` (пользуется ли контакт сервисом) и если `Person` есть, то сверяем его список контактов с нашим и возвращаем совпадения.

> **Предложение: Определите уникальные индексы/ограничения:**
> -   `UNIQUE (telegram_id)` (если id всегда заполнен и уникален).
> -   `UNIQUE (username)` (с оговоркой, что `null` значения не считаются дубликатами).
> -   `UNIQUE (phone_number)` (аналогично, с оговоркой на `null`).
> -   Рассмотреть частичные уникальные индексы (например, `UNIQUE INDEX idx_ta_username_notnull ON Telegram_account (username) WHERE username IS NOT NULL;` в PostgreSQL).

> **Установка `is_verified=True`:**
> -   Если "канонический" аккаунт уже существовал, `Contact` просто переключается на него. У него, скорее всего, `is_verified=True`.
> -   Если "канонический" аккаунт не существовал, заполняем данные текущего (по номеру) и делаем его "каноническим", установив `is_verified=True`. Это логично завершает процесс "верификации" этого аккаунта.

---

### Внесены правки в план

> ## ⚠️ Техническое ограничение Telegram
>
> Бот Telegram **по соображениям приватности** не может получить информацию о пользователе (например, `telegram_id`, `first_name`) по номеру телефона или `username` напрямую. Такая возможность была бы серьёзной уязвимостью.
>
> Бот может получить данные о пользователе только в двух случаях:
> 1.  Пользователь сам взаимодействует с ботом (например, нажимает кнопку **"Start"**).
> 2.  Другой пользователь делится контактом через интерфейс Telegram (в том числе внутри Mini App).

### Проблема с исходным планом

Это означает, что шаг из плана:
> _"Отправляем данные в Telegram Bot API → получаем ответ → сохраняем"_

технически невыполним, если речь идёт о простом вводе `username` или `phone_number` без прямого взаимодействия пользователя с ботом.

### Адаптация плана к реальности

Логика "альтернативного варианта" реализуется с учётом ограничений Telegram. Вместо вызова Bot API создадим "заглушку" (запись-заглушку) при вводе номера телефона.
Процесс верификации и слияния произойдёт позже — когда сам владелец этого номера **авторизуется в приложении** через Telegram.

## Слияние (верификация) TelegramAccount

Когда пользователь с ранее введённым номером телефона впервые авторизуется в Mini App, система выполняет следующие шаги:

### 1. Обнаружение дубля

Система находит два `TelegramAccount` для одного и того же человека:
-   **"Заглушка"** — создана по номеру телефона, `is_verified = False`.
-   **"Канонический"** — создан при авторизации через Telegram, `is_verified = True`.

### 2. Перенос связей

Система **не объединяет** записи напрямую. Вместо этого:
-   Находит все карточки `Contact`, привязанные к **"заглушке"**.
-   "Переключает" их связь на **"канонический"** аккаунт.

### 3. Архивация дубля

После переноса всех связей:
-   Запись-заглушка помечается как `is_active = False`.
-   Она больше **не участвует в логике приложения**, но остаётся в БД для аудита.

✅ **Итог:**
Сохраняем возможность "предзаполнения" контактов по номеру, но **финальная верификация и активация** происходят только при **реальной авторизации через Telegram**.
