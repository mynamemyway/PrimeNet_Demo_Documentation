# План разработки базы данных

## Авторизация:
1.  По API получаем  `initData`  с данными
2.  Проверяем наличие  `Telegram_account`  в БД по `id telegmam`
    a.  если нет - Создаём сущности  `Telegram_account`   и  `Person`  c нашими ID
    b.  если есть  - Используем имеющийся `Telegram_account`
3.  Прикрепляем к  `Person`  ссылкой   `Telegram_account`
4.  Автоматически наполняем наш  `Telegram_account`  данными из  `initData`  (user) + :
    a.    `"id"`: 123456789
    b.    `"is_bot"`: false,
    c.    `"first_name"`: "John",
    d.    `"last_name"`: "Doe",
    e.    `"username"`: "johndoe",
    f.    `"language_code"`: "en",
    g.    `"is_premium"`: true,
    h.    `"added_to_attachment_menu"`: false,
    i.    `"allows_write_to_pm"`: true,
    j.    `"photo_url"`: " https://t.me/i/userpic/320/johndoe.jpg "
5.  Автоматически заполняются поля для  `Telegram_account`  и для  `Person` :
    a.  `created_at` # - дата добавления сущности (TIMESTAMP)
    b.  `updated_at` # - дата последнего обновления сущности (TIMESTAMP)
6.  Ставим флаг  `is_verified=True`, который указывает, что  `Telegram_account`  заполнен и был авторизован в системе (живой аккаунт).
7.  Дополнительные поля для ручного ввода для нашего  `Telegram_account` :
    a.  `phone_number`
8.  Создаём собственную карточку  `Contact`  для  `Person`  с флагом `is_self=True`
9.  Заполняем:
    a.  `your_link` # ссылка на любой ресурс для парсинга
    b.  Предлагается кнопка "+", чтобы добавить ссылки на социальные сети из нашего списка соц. сетей
    c.  Далее по списку поля для `Contact` заполняются автоматически после парсинга или вручную при необходимости

## Добавление Контакта по `id telegmam` или `username` (верифицированного аккаунта):
1.  `Person`  создаёт  `Contact`  и вводит `id telegmam` или `username`
2.  Проверяем в БД наличие  `Telegram_account`  с этими данными (приоритет - `id telegmam`)
    a.  Если есть - прикреплем ссылку на имеющийся `Telegram_account`
    b.  Если нет - создаём новый `Telegram_account`
3.  Заполняем Контакт:
    a.  `your_link` # ссылка на любой ресурс для парсинга
    b.  Предлагается кнопка "+", чтобы добавить ссылки на социальные сети из нашего списка соц. сетей
    c.  Далее по списку поля для `Contact` заполняются автоматически после парсинга или вручную при необходимости

## Добавление Контакта по `phone_number`:
1.  `Person` создаёт `Contact`  и вводит только `phone_number`
2.  Проверяем в БД наличие `Telegram_account` с этим `phone_number`
    a.  Если находим, прикрепляем `Contact`  ссылкой к имеющемуся `Telegram_account`
    b.  Если нет, создаём  `Telegram_account` с `is_verified=False` и прикрепляем к нему  `Contact`
Если позже этот  `Telegram_account`  получает `id telegram` или `username`, проверяем в БД наличие такого  `Telegram_account`.  Если есть - привязываем  `Contact` к нему, но сохраняем телефон, если он не указан в верифицированном `Telegram_account`. Текущий дубль отправляем в архив - ставим флаг `is_active=False`.
Если нет, заполняем текущий  `Telegram_account`  и ставим  `is_verified=True`
3.  Заполняем Контакт:
    a.  `your_link` # ссылка на любой ресурс для парсинга
    b.  Предлагается кнопка "+", чтобы добавить ссылки на социальные сети из нашего списка соц. сетей
    c.  Далее по списку поля для `Contact` заполняются автоматически после парсинга или вручную при необходимости

## Остальные Поля для сущности  `Contact`  отдельно в таблице, категории кратко:
1.  Ссылки на социальные сети (main link for parser)
2.  Дополнительные личные данные
3.  Предпочтения и взгляды
4.  Профессиональные и финансовые данные
5.  Дополнительная информация (для контекста и ИИ)

## Парсинг:
1.  Пользователь видит поле для соц. сетей `your_link`
2.  После ввода ссылки в `your_link`  запускаются `t-a` (text) и `i-a` (image) парсеры в фоновом режиме - User получает уведомление о начале сбора данных.
3.  Сбор данных сохраняется в `parsed_data`, User видит заполненные поля для сохранения.

*Поле*  `shared_contacts`  отображает все  `Contact`  данного  `Contact` , если он является  `Person` , то есть использует сервис сам.

*Далее сделаем апгрейд:* каждая социальная сеть - это объект. Пользователь может заполнить любое поле соц. сети ссылкой, получить данные порсингом и эти данные заполняют объект конкретной соц сети и сохраняются в `Contact` этого `Person`. Пользователь может кнопкой "+" добавить данные из любого поля любой соц. сети в основное поле своего `Contact` соответственно.
**Поля:**
1.      `your_link` # ссылка для парсинга (временно так)
2.      `vk_link` # ссылка на VK
3.      `facebook_link` # ссылка на Facebook (Meta)
4.      `Instagram_link` # ссылка на Instagram (Meta)
5.      `tiktok_link` # ссылка на TikTok
6.      `x_link` # ссылка Twitter
7.      `youtube_link` # ссылка на YouTube
8.      `discord_link` # ссылка на Discord
9.      `linkedin_link` # ссылка на LinkedIn
10.     `pinterest_link` # ссылка Pinterest
11.     `wechat_link` # ссылка на WeChat (asia)
12.     `line_link` # ссылка на line (asia)

## Подробнее о сущностях БД:
1.  `Person`  - имеет уникальный внутренний ID, самый глобальный и абстрактный объект. В перспективе может хранить несколько разных аккаунтов для одного реального человека, например при реализации фичи  `KYC` .
 У одного человека может быть несколько  `Person` , количество зависит от количества используемых им  `Telegram_account`  == `phone_number`.
2.  `Telegram_account`  - хранит базовые данные о  `Person` , является зеркалом аккаунта в телеграм.
Один  `Telegram_account`  ссылается на одну  `Person`.
3.  `Contact`  - это персонализированная страница личного контакта из телефонной книги для конкретного  `Person` .
 `Contact`  может иметь множество уникальных персонализированных вариаций одного  `Telegram_account` , т.к. создаётся разными пользователями.
Каждая сущность имеет автоматические поля:
·      `created_at` # - дата добавления Contact (TIMESTAMP)
·      `updated_at` # - дата последнего обновления Contact (TIMESTAMP)

## Основные поля для ввода и парсинга в сущность  `Contact` :
    # Ссылки на социальные сети
·      `your_link` # ссылка для парсинга - сейчас для парсинга только это поле
·      `vk_link` # ссылка на VK  - 1
·      `facebook_link` # ссылка на Facebook (Meta)  - 1
·      `Instagram_link` # ссылка на Instagram (Meta)  - 1
·      `tiktok_link` # ссылка на TikTok  - 1
·      `x_link` # ссылка Twitter  - 1
·      `youtube_link` # ссылка на YouTube  - 1
·      `discord_link` # ссылка на Discord  - 1
·      `linkedin_link` # ссылка на LinkedIn  - 1
·      `pinterest_link` # ссылка Pinterest  - 1
·      `wechat_link` # ссылка на WeChat (asia)  - 1
·      `line_link` # ссылка на line (asia)  - 1
·      `your_link` # ссылка на любой ресурс по выбору пользователя (Вручную) - 1
    # Дополнительные личные данные
       `first_name= Column(String, index=True)`  #  Имя. (Вручную, обязательное поле) - 1
       `last_name = Column(String, index=True)`  #  Фамилия. (Вручную) - 1
·      `middle_name = Column(String, index=True)`  # Отч. (Вручную) - 1
       `extra_phone_number = Column(String, index=True)` # Телефон, кот. знает Person (Вручную) - 1
·      `email = Column(String, nullable=True)`  # Почта (Вручную) - 1
·      `country = Column(String, nullable=True)`  # Страна - 1
·      `city = Column(String, nullable=True)`  # Город - 1
·      `address = Column(Text, nullable=True)`  # Адрес по которому проживает - 1
·      `date_of_birth = Column(Date, nullable=True)`  # Дата рождения - 1
·      `height = Column(Numeric(5, 2), nullable=True)`  # Рост (например, 1.75м) - 1
·      `weight = Column(Numeric(5, 2), nullable=True)`  # Вес (например, 70.5 кг) - 1
    # Предпочтения и взгляды
·      `religious_views = Column(Text, nullable=True)`  # Религиозные взгляды - 2
·      `political_views = Column(Text, nullable=True)`  # Политические взгляды - 2
·      `personal_qualities = Column(Text, nullable=True)` # Личные качества - 2
·      `personal_values = Column(Text, nullable=True)`  # Личные ценности - 2
·      `content_preferences = Column(Text, nullable=True)`  # Предпочтения в контенте - 2
·      `music_preferences = Column(Text, nullable=True)`  # Предпочтения в музыке - 2
·      `drink_preferences = Column(Text, nullable=True)`  # Предпочтения в напитках - 2
·      `food_preferences = Column(Text, nullable=True)`  # Предпочтения в еде - 2
·      `harmful_habits = Column(Text, nullable=True)`  # Вредные привычки - 2
·      `health = Column(Text, nullable=True)`  # Здоровье - 2
·      `clothing_style = Column(Text, nullable=True)`  # Стиль одежды - 2
·      `lifestyle = Column(Text, nullable=True)`  # Стиль жизни - 2
·      `hobbies = Column(Text, nullable=True)` # Хобби - 2
    # Профессиональные и финансовые данные
·      `development_sphere = Column(Text, nullable=True)`  # Сфера развития - 1
·      `skills = Column(Text, nullable=True)` # Навыки - 1
·      `capital = Column(Numeric(15, 2), nullable=True)`  # Капитал (например 1000000.00) - 1
·      `capital_currency = Column(String, nullable=True)` # Валюта капитала - 1
·      `assets = Column(Text, nullable=True)`  # Активы (например бизнес) - 1
·      `income_sources = Column(Text, nullable=True)`  # Источники дохода - 1
·      `investment = Column(Text, nullable=True)`  # Инвестиции - 1
    # Дополнительная информация (для контекста и ИИ)
·      `secrets = Column(Text, nullable=True)`  # Секреты - 2
·      `problems = Column(Text, nullable=True)`  # Проблемы - 2
·      `photos_url` # ссылки на изображения, которые были обработаны i-анализом - 2
    # Автоматические поля (авторасчёт)
·      `shared_contacts` # getSharedContacts() - автоподбор списка общих контактов
·      `age` # - возраст Contact
·      `created_at` # - дата добавления Contact (TIMESTAMP)
·      `updated_at` # - дата последнего обновления Contact (TIMESTAMP)

0 - Поля  которые заполняются только пользователем или автоматически / при t-анализе
1 - Поля  с приоритетом t-анализа (заполняются при i-анализе только если не заполнены после t-анализа)
2 - Поля  для конкатенации (всегда дополняются найденными после i-анализа данными)

## Примечания
 `Telegram_account`, созданный при добавлении чужого контакта, существует как "контейнер данных" и не обязательно связан с каким-либо Person на момент создания. Связь с Person произойдет, если этот человек сам авторизуется в системе.
При обновлении Telegram_account по phone_number добавьте проверку на существование Telegram_account с таким же id или username. Если он существует, объедините данные (аналогично логике при добавлении контакта) — перенесите связанные Contact с "старого" (по номеру) на "новый" (по id/username), а "старый" пометьте как архивный или удалите.
Флаг `is_verified=False` Это маркер неполных данных.
Уточнение семантики флага - `is_verified=True` "аккаунт подтвержден через Telegram API"
`getSharedContacts()` - автоподбор списка общих контактов.
Мы проверяем, есть ли у контакта прикреплённый Person (пользуется ли контакт сервисом) и если Person есть, то мы сверяем его список контактов с нашим и возвращаем совпадения.

Предложение: Определите уникальные индексы/ограничения:
`UNIQUE (telegram_id)` (если id всегда заполнен и уникален).
`UNIQUE (username)` (с оговоркой, что null значения не считаются дубликатами).
`UNIQUE (phone_number)` (аналогично, с оговоркой на null).
Рассмотрите частичные уникальные индексы (например, `UNIQUE INDEX idx_ta_username_notnull ON Telegram_account (username) WHERE username IS NOT NULL;` в PostgreSQL).
Установка `is_verified=True`:
Если "канонический" аккаунт уже существовал, `Contact` просто переключается на него. У него, скорее всего, `is_verified=True`.
Если "канонический" аккаунт не существовал, заполняем данные текущего (по номеру) и делаем его "каноническим", установив `is_verified=True`. Это логично завершает процесс "верификации" этого аккаунта.


### Внесены правки в план:
## ⚠️ Техническое ограничение Telegram

Бот Telegram **по соображениям приватности** не может получить информацию о пользователе (например, `telegram_id`, `first_name`) по номеру телефона или `username` напрямую. Такая возможность была бы серьёзной уязвимостью.

Бот может получить данные о пользователе только в двух случаях:
1. Пользователь сам взаимодействует с ботом (например, нажимает кнопку **"Start"**).
2. Другой пользователь делится контактом через интерфейс Telegram (в том числе внутри Mini App).

### Проблема с исходным планом
Это означает, что шаг из плана:
> _"Отправляем данные в Telegram Bot API → получаем ответ → сохраняем"_
технически невыполним, если речь идёт о простом вводе `username` или `phone_number` без прямого взаимодействия пользователя с ботом.

### Адаптация плана к реальности
Логика "альтернативного варианта" реализуется с учётом ограничений Telegram.
Вместо вызова Bot API создадим "заглушку" (запись-заглушку) при вводе номера телефона.  
Процесс верификации и слияния произойдёт позже — когда сам владелец этого номера **авторизуется в приложении** через Telegram.

## Слияние (верификация) TelegramAccount
Когда пользователь с ранее введённым номером телефона впервые авторизуется в Mini App, система выполняет следующие шаги:

### 1. Обнаружение дубля
Система находит два `TelegramAccount` для одного и того же человека:
- **"Заглушка"** — создана по номеру телефона, `is_verified = False`.
- **"Канонический"** — создан при авторизации через Telegram, `is_verified = True`.

### 2. Перенос связей
Система **не объединяет** записи напрямую. Вместо этого:
- Находит все карточки `Contact`, привязанные к **"заглушке"**.
- "Переключает" их связь на **"канонический"** аккаунт.

### 3. Архивация дубля
После переноса всех связей:
- Запись-заглушка помечается как `is_active = False`.
- Она больше **не участвует в логике приложения**, но остаётся в БД для аудита.

✅ **Итог:**  
Сохраняем возможность "предзаполнения" контактов по номеру, но **финальная верификация и активация** происходят только при **реальной авторизации через Telegram**.

